<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Pilot</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: monospace;
      background: #000;
      color: #0f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 8px;
    }
    #output {
      flex: 1;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.3;
      overflow: hidden;
    }
    #input-row {
      display: flex;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid #333;
    }
    #text-input {
      flex: 1;
      background: #111;
      border: 1px solid #333;
      color: #0f0;
      padding: 8px;
      font-family: monospace;
      font-size: 14px;
    }
    #mic {
      background: #111;
      border: 1px solid #333;
      color: #0f0;
      padding: 8px 16px;
      font-size: 18px;
    }
    #mic.recording { background: #300; color: #f00; }
    .error { color: #f44; }
  </style>
</head>
<body>
  <div id="output">Connecting...</div>
  <div id="input-row">
    <input type="text" id="text-input" placeholder="command" autocomplete="off">
    <button id="mic">‚óè</button>
  </div>

  <div id="auth" style="display:none; position:fixed; inset:0; background:#000; padding:20px;">
    <input type="password" id="token" placeholder="token" style="width:100%; padding:8px; background:#111; border:1px solid #333; color:#0f0; font-family:monospace;">
  </div>

<script>
const output = document.getElementById('output');
const textInput = document.getElementById('text-input');
const mic = document.getElementById('mic');
const auth = document.getElementById('auth');
const tokenInput = document.getElementById('token');

let ws = null;
let token = localStorage.getItem('pilot_token');
let mediaRecorder = null;
let chunks = [];

function getScreenInfo() {
  return {
    w: window.innerWidth,
    h: window.innerHeight,
    cols: Math.floor(window.innerWidth / 8),  // approx char width
    rows: Math.floor((window.innerHeight - 50) / 18)  // approx line height
  };
}

function connect() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(`${proto}//${location.host}/ws?token=${token}`);

  ws.onopen = () => {
    // Request initial status
    ws.send(JSON.stringify({ type: 'cmd', text: 'status', screen: getScreenInfo() }));
  };

  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    if (data.type === 'display') {
      // Just show what Gemini generated
      output.innerHTML = data.html || data.text || '';
    } else if (data.type === 'error') {
      output.innerHTML = `<span class="error">${data.message}</span>`;
    }
  };

  ws.onclose = (e) => {
    if (e.code === 4001) {
      localStorage.removeItem('pilot_token');
      token = null;
      auth.style.display = 'block';
    } else {
      output.textContent = 'Disconnected. Reconnecting...';
      setTimeout(connect, 2000);
    }
  };

  ws.onerror = () => {
    output.textContent = 'Connection error';
  };
}

function send(text, audio) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  const msg = { type: 'cmd', screen: getScreenInfo() };
  if (text) msg.text = text;
  if (audio) msg.audio = audio;
  // GPS if available
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      p => { msg.gps = { lat: p.coords.latitude, lon: p.coords.longitude }; },
      () => {}, { timeout: 1000 }
    );
  }
  ws.send(JSON.stringify(msg));
  output.textContent = '...';
}

// Text input
textInput.onkeydown = (e) => {
  if (e.key === 'Enter' && textInput.value.trim()) {
    send(textInput.value.trim());
    textInput.value = '';
  }
};

// Voice
mic.onclick = async () => {
  if (mediaRecorder?.state === 'recording') {
    mediaRecorder.stop();
    mic.classList.remove('recording');
    return;
  }
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    chunks = [];
    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      stream.getTracks().forEach(t => t.stop());
      const blob = new Blob(chunks, { type: 'audio/webm' });
      const reader = new FileReader();
      reader.onloadend = () => send(null, reader.result.split(',')[1]);
      reader.readAsDataURL(blob);
    };
    mediaRecorder.start();
    mic.classList.add('recording');
  } catch (err) {
    output.innerHTML = `<span class="error">Mic: ${err.message}</span>`;
  }
};

// Auth
tokenInput.onkeydown = (e) => {
  if (e.key === 'Enter' && tokenInput.value.trim()) {
    token = tokenInput.value.trim();
    localStorage.setItem('pilot_token', token);
    auth.style.display = 'none';
    connect();
  }
};

// Start
if (token) connect();
else auth.style.display = 'block';
</script>
</body>
</html>
